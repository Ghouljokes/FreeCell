Game class:
    attributes:
        screen, foundation, free cells, tableau, deck, held_card, running
    
    create_game:
        game.create_screen
        game.create_foundation
        game.create_free_cells
        game.create_tabluau
        set cards to a deck
        game.add_cards
        held_card is None
        last_click = now
        moves = []

    @property
    column_spaces:
        set column_spaces to top spaces for each column of the tableau
        return column_spaces

    @property
    empty_cells:
        set empty_cells to 0
        iterate through spaces in free cells and tabs:
            if space is empty:
                empty_cells += 1
        return empty_cells

    @property
    spaces:
        return all spaces on the game board.

    auto_move(card):
        for space in foundations + columns + freecells:
            move_made = self.try_move(card, space)
            if move_made:
                return

    check_click_type(target):
        set click_time to now
        time_between is click_time - self.last_click_time
        if time_between <= DOUBLECLICKTIME and target == self.last_target:
            return "double"
        return "single"



    create_foundation
        create foundation spaces in upper left
        create region for foundation

    create_free_cells
        create free cells in upper right
        create region for free cells

    create_tableau
        create 8 tableau columns
        create tableau region at lower portion of screen
    
    deal_cards:
        shuffle deck
        start at first tableau
        for card in deck:
            tableau.stack_card(card)
            card.go_home
            if not last tab:
                move to next tab
            else:
                go back to first tab
    
    draw:
        for each space:
            space.draw
        if held_card:
            held_card.draw

    get_mouse_target:
        Check each region to see if mouse is in it.
            if mouse in region:
                for space in region:
                    space.check_for_target
                    if target is card:
                        return target

    get_release_destination(card):
        for space in foundations, free_cells, columns:
            if card.can_drop_off(space):
                return space
        return None

    handle_events:
        get events
        for event in events:
            game.handle_event
    
    handle_event(event):
        if event is quit event:
            game.running = false
        elif event is mouse down:
            game.handle_mouse_down
        elif event is mouse up:
            game.handle_mouse_up
        elif event is z key:
            self.undo

    handle_mouse_down:
        set target to game.get_mouse_target
        if target:
            click_type = self.check_click_type(target)
            if single click:
                self.handle_single_click(target)
            elif double click:
                self.handle_double_click(target)


    handle_single_click(target):
        if target is card and card.is_valid_stack:
            self.held_card = target
            set self.last_click to now
            set self.last_target to target
            target.click(cursor position)

    handle_double_click(target):
        if target is card:
            self.auto_move(card)

    handle_mouse_up:
        if held_card:
            self.release_card()

    make_move(card, space, undo=False):
        if not undo:
            create move dict with card, source, and space
            append move to self.moves
        card.switch_space(space)

    release_card:
        if not held_card:
            return
        dest = self.get_release_dest(held_card)
        if dest:
            self.try_move(held_card, dest)
        held_card.release()
        set self.held_card to None

    room_for_move(card, space):
        available_space = self.free_spaces
        if space is StackSpace or Foundation:
            available_space += 1
        return card.stack_size <= available_space

    run:
        while game.running:
            game.tick
    
    tick:
        game.draw
        game.handle_events
        game.update

    try_move(card, space):
        if self.valid_dest(card, space):
            self.make_move(card, space)
            return True
        return False

    undo:
        if move in move list:
            take card, dest, and source on last move in list
            call self.make_move to move card from dest to source with undo set to True.
            remove last move from move list

    update:
        if held_card:
            *card.drag to mouse location*
+++
    valid_dest(card, space):
        return self.room_for_move(card, space) and space.valid_dest(card)
+++
    