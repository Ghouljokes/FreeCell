Game class:
    attributes:
        screen, foundation, free cells, tableau, deck, held_card, running
    
    create_game:
        game.create_screen
        game.create_foundation
        game.create_free_cells
        game.create_tableau
        game.add_cards
        held_card is None
        last_click = now
        moves = []

    @property
    column_spaces:
        set column_spaces to top spaces for each column of the tableau
        return column_spaces

    @property
    empty_cells:
        set empty_cells to 0
        iterate through spaces in free cells and tabs:
            if space is empty:
                empty_cells += 1
        return empty_cells

    auto_move(card):
        for space in foundations + columns + freecells:
            if self.valid_dest(card, space):
                self.make_move(card, space)
                return

    check_release_type:
        set release_time to now
        time_between is click_time - self.last_click_time
        if time_between <= CLICKRELEASETIME:
            return "click_release"
        else:
            return hold_release

    click_card(target):
        if target is card and card.is_valid_stack:
            self.held_card = target
            target.click(cursor position)

    create_foundation
        create foundation spaces in upper left

    create_free_cells
        create free cells in upper right

    create_tableau
        create 8 tableau columns

    deal_cards:
        create deck
        shuffle deck
        start at first tableau
        for card in deck:
            tableau.stack_card(card)
            card.go_home
            if not last tab:
                move to next tab
            else:
                go back to first tab

    draw:
        reset screen
        for each space:
            space.draw(self.screen)
        if held_card:
            held_card.draw(self.screen)

    get_mouse_target:
        for space in foundations, free_cells, tableaus"
            space.check_for_target
            if target is card:
                return target

    get_release_destination(card):
        for space in foundations, free_cells, columns:
            if card.can_drop_off(space):
                return space
        return None

    handle_events:
        get events
        for event in events:
            game.handle_event
    
    handle_event(event):
        if event is quit event:
            game.running = false
        elif event is mouse down:
            game.handle_mouse_down
        elif event is mouse up:
            game.handle_mouse_up
        elif event is z key:
            self.undo

    handle_click_release:
        if held_card:
            self.auto_move(held_card)
            self.held_card.release()
            self.held_card = None

    handle_hold_release:
        if not held_card:
            return
        dest = self.get_release_dest(held_card)
        if dest and self.valid_dest(held_card, dest):
            self.make_move(card, dest)
        held_card.release()
        self.held_card = None

    handle_mouse_down:
        set target to game.get_mouse_target
        set self.last_click to now
        if target:
            self.click_card(target)

    handle_mouse_up:
        release_type = self.check_release_type
        if release_type is click_release:
            self.handle_click_release
        else:
            self.handle_hold_release

    make_move(card, space, undo=False):
        if not undo:
            create move dict with card, source, and space
            append move to self.moves
        card.switch_space(space)




    room_for_move(card, space):
        available_space = self.free_spaces
        if space is StackSpace or Foundation:
            available_space += 1
        return card.stack_size <= available_space

    run:
        while game.running:
            game.tick
    
    tick:
        game.draw
        game.handle_events
        game.update

    try_move(card, space):
        if self.valid_dest(card, space):
            self.make_move(card, space)
            return True
        return False

    undo:
        if move in move list:
            take card, dest, and source on last move in list
            call self.make_move to move card from dest to source with undo set to True.
            remove last move from move list

    update:
        if held_card:
            *card.drag to mouse location*

    valid_dest(card, space):
        return self.room_for_move(card, space) and space.valid_dest(card)
    