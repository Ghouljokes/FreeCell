class Space:
    attributes:
        rect, cards

    create space(position)
        set rect at position
        set cards to []

    is_empty:
        return if length of space.cards is 0

    @property
    card:
        if not empty:
            return last card in self.cards

    add_card(card):
        set card's space as self
        self.cards.append(card)

    check_for_target(cursor location):
        if cursor in rect and cards not empty:
            return space.card


    draw(screen):
        draw rectangle
        if not empty:
            space.card.draw 

    remove_card:
        remove last entry in self.cards

    valid_dest(card):
        return space.isempty and space intersects card***


class StackSpace(space):
    attributes:
        parent_card, cards, rect

    create_space(card):
        set parent_card to card variable
        position is parent_card's topleft offset by the stack offset
        Space.__init__(position)

    def move(location):
        set rect to new location
        if card in space, move card along with space.

***
class Foundation(space):

    __init__(self, position):
        Space.__init__(position)
        self.all_cards = []



    valid_dest(card):
        if empty or given card is same suit and one heigher, AND spaces intersect, AND card isn't stacked:
            return self
***     

class Tableau(Space):

    @property
    top_card:
        set highest_card to self.card
        if highest_card:
            while highest_card has card above it:
                set highest_card to above card
            return highest card

    @property
    top_space:
        if top_card:
            return top_card.space
        else:
            return else
    
    check_for_target:
        if cursor x within tableau x:
            target_card = self.top_card
            while target card:
                if cursor within card rect:
                    return card
                else:
                    target card = card.below_card

    stack_card(card):
        self.top_space.add_card(card)
    
    valid_dest(card):
        if self.card:
            return top_space.valid_dest(card)
        else:
            return super().valid_Dest(card)